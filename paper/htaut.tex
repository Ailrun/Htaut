\documentclass[a4paper, 12pt]{oblivoir}

% Settings for Document itself
\usepackage{fapapersize}
\usepackage{geometry}
\usepackage{fix-cm}
\usepackage{indentfirst}
\usepackage{setspace}
% \usepackage{background}
\linespread{1.6}

\renewcommand{\abstractname}{초록}

% Settings for Source code
\usepackage{minted}

% Settings for Diagram
\usepackage{tikz}

% Settings for Mathmatics
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage{enumitem}

\newcommand{\texttype}[1]{{\bfseries\ttfamily#1}}

\begin{document}
\newgeometry{top=2.3cm,bottom=1.5cm,left=3cm,right=3cm}
\begin{titlingpage}
  \begin{center}
    \vspace*{2\baselineskip}
    \fontsize{24}{24}\selectfont
    Htaut:
%    \vspace*{\baselineskip}

    Haskell 일체형 동어반복 증명 라이브러리
%    \vspace*{\baselineskip}

    \fontsize{20}{20}\selectfont
    Htaut:
    
%    \vspace*{\baselineskip}
    Haskell-integrated TAUtology prover for Type-level

    \vspace*{2\baselineskip}
    \fontsize{18}{18}\selectfont
    지도교수 : 허충길

    \vspace*{\baselineskip}
    이 논문을 공학학사 학위 논문으로 제출함.

    \vspace*{2\baselineskip}
    2016년 12월 4일

    \vspace*{3\baselineskip}
    서울대학교 공과대학\\
    컴 퓨 터 공 학 부\\
    장 준 영

    \vspace*{\baselineskip}
    2017년 2월
  \end{center}
\end{titlingpage}
\restoregeometry{}

\title{Htaut:\\
  Haksell 일체형 동어반복 증명 라이브러리\\
  \Large
  Htaut:\\
  Haskell-integrated TAUtology prover for Type-level}
\author{화학부 장준영}
\date{\today}

\maketitle{}

\begin{abstract}
  현대에는 많은 정리 증명 언어들과 정리 증명 프로그램들이 있으나,
  범용 프로그래밍 언어 내에서 정리 증명을 지원하는 문법이나 라이브러리는 찾기 힘들다.
  % 이는 많은 범용 프로그래밍 언어가 의존 타입을 지원하지 않기 때문에 정리 증명 언어들이 사용하는 방식을 그대로 사용하기 힘들기 때문이다.
  본 논문에서는 순수 함수형 범용 프로그래밍 언어인 Haskell 내에 동어반복명제 증명 라이브러리를 구현하는 방법에 대해 살펴보고,
  독립된 정리 증명기와 구분되는 기능인 동어반복명제에 의한 함수 변환을 살펴볼 것이다.

  % TODO: 초록 재검토
\end{abstract}

\section{서론}
현대에는 Coq 등 많은 정리 증명 언어나 정리 증명 프로그램들이 있다.
그러나 이들의 프로그래밍 언어로서의 기능은 Turing Completeless 등의 이유로 완전하지 않은 경우가 많고,
정리 증명을 주 목적으로 사용하는 경우가 많다.

이와는 반대로 범용 프로그래밍 언어로 동작하는 언어들에는 정리 증명을 위한 기능이나 라이브러리가 상대적으로 매우 적다.

% TODO: 서론 내용 확보

\section{본론}
\subsection{동어반복명제}
동어반복명제 (Tautology) 란, 명제의 진리치가 명제에 포함된 연결어 (또는, 따라서, 그리고) 에 의해서 결정되는 명제들을 말한다.
이를테면 다음과 같은 명제이다.
\begin{quotation}
  \noindent\small
  \begin{enumerate}
  \item 침대가 가구이고 침대가 상품이면, 침대는 가구이다.
  \item 사람은 반드시 죽으면, 사람은 반드시 죽거나 모든 휴대폰은 삼성 제품이다.
  \item 희경이가 책을 읽고 있고 또 희경이가 책을 읽지 않고 있다는 것은 동시에 참일 수 없다.
  \end{enumerate}  
\end{quotation}

동어반복명제는 명제 문자들 ($P$, $Q$, $R$, \ldots{}) 과 연결어들로 표현할 수 있다.
이때, 명제 문자들은 주로 P 로 시작하는 대문자들을 사용하며,
연결어들은 주로 다음과 같은 것들을 사용한다.

\begin{enumerate}
\item 그리고, 논리곱, And, \ldots{}
  \begin{itemize}
  \item $\wedge{}$, $\cdot{}$, and, \ldots{}
  \end{itemize}
\item 또는, 논리합, Or, \ldots{}
  \begin{itemize}
  \item $\vee{}$, $+$, or, \ldots{}
  \end{itemize}
\item \--는 아닌, 논리부정, Not, \ldots{}
  \begin{itemize}
  \item $\neg{}$, not, \ldots{}
  \end{itemize}
\item \--이면, 조건문, If, \ldots{}
  \begin{itemize}
  \item $\rightarrow{}$, if, \ldots{}
  \end{itemize}
\item \--일 때 그때만, 쌍조건문, If and only if, \ldots{}
  \begin{itemize}
  \item $\leftrightarrow{}$, iff, \ldots{}
  \end{itemize}
\end{enumerate}

이들을 사용해 위에서 나왔던 예제들을 다음과 같이 다시 나타날 수 있다.
\begin{quotation}
  \noindent\small
  \begin{enumerate}
  \item $P \wedge{} Q \rightarrow{} P$
  \item $P \rightarrow{} P \vee{} Q$
  \item $\neg{}(P \wedge{} \neg{}P)$
  \end{enumerate}
\end{quotation}

% TODO: 문단 끝맺음 및 내용 추가

\subsection{함수를 통한 동어반복명제의 증명}
Coq 등의 언어에 의해 이미 이용되고 있는 것처럼,
동어반복명제는 그 명제를 타입으로 가지는 함수를 통해서 증명할 수 있다.

다음과 같이 가정하자.

\begin{enumerate}
\item \texttype{Int} (정수 타입) 와 같이 원소를 가지는 간단한 타입을 True, \texttype{Bot} ($\bot{}$ 타입) 과 같이 원소를 가지지 않는 간단한 타입을 False 인 명제라고 하자.
\item $P \wedge{} Q$ 는 \texttype{P * Q} (곱 타입, 튜플 타입) 으로 나타내자.
\item $P \vee{} Q$ 는 \texttype{P + Q} (합 타입, 유니온 타입) 으로 나타내자.
\item $P \rightarrow{} Q$ 는 \texttype{P -> Q} (함수 타입) 으로 나타내자.
\end{enumerate}

이때, 원소를 하나라도 가지는 모든 타입은 참임을 다음과 같이 보일 수 있다.

% TODO: 참고문헌 및 설명 추가
\subsubsection{증명과 모나드}

% 필요한가????

\subsection{함수 변환과 안전성}
\subsubsection{함수 변환}
증명은 함수 변환을 위해서 사용될 수 있다.
다른 말로는 증명된 동어반복명제를 통해서 한 함수를 새로운 함수로 바꿀 수 있다.

이는 증명이 함수를 통해서 이루어진다는 점과
두 함수를 합성하여 새로운 함수를 만들어내는 것이 가능하다는 점을 생각해보면 자명하다.

다음과 같은 경우를 생각해보자.

\begin{itemize}[noitemsep]
  \small
\item 증명된 명제
  \begin{itemize}
  \item $T$: $(P \rightarrow{} Q \rightarrow{} R) \rightarrow{}
    (P \rightarrow{} Q \rightarrow{} S) \rightarrow{}
    P \rightarrow{} Q \rightarrow{} R \wedge{} S$
  \end{itemize}

\item 가지고 있는 함수
  \begin{itemize}
  \item f: \texttype{Int -> Int -> Bool}
  \item g: \texttype{Int -> Int -> Ordering}
\end{itemize}

\end{itemize}

이 경우, 두 함수 f, g 를 명제 $T$의 전제로 사용하여 다음과 같은 새로운 함수를 만들어낼 수 있다.

\begin{itemize}[noitemsep]
  \small
\item 새로운 함수
  \begin{itemize}
  \item h: \texttype{Int -> Int -> (Bool, Ordering)}
  \end{itemize}
\end{itemize}

\subsubsection{안전성}
안전성이란 원래 타입에서 새 타입으로의 변환이 결정적으로 이루어지는 성질을 말하기로 하자.
이를테면, 임의의 타입 \texttype{P}, \texttype{Q} 에 대해서

\begin{itemize}[noitemsep]
\item f: \texttype{P -> Q}
\end{itemize}

에서

\begin{itemize}[noitemsep]
\item g: $\forall{}$\texttype{R} . \texttype{R -> P -> Q}
\end{itemize}

로의 변환은 타입 \texttype{P}, \texttype{Q}, \texttype{R} 에 대한 정보가 아무것도 없기 때문에,

\begin{itemize}[noitemsep]
\item g(r) = f 
\end{itemize}

와 동등한 변환 외에는 만들 수 있는 방법이 없다.
따라서 이 두 함수간의 변환은 결정적이고, 안전하다.

반면에 임의의 타입 \texttype{P}, \texttype{Q} 에 대해서

\begin{itemize}[noitemsep]
\item f: \texttype{Int -> P -> Q}
\end{itemize}

에서

\begin{itemize}[noitemsep]
\item g: \texttype{P -> Q}
\end{itemize}

로의 변환은, 타입 \texttype{Int} 의 값들을 알고 있기 때문에,

\begin{itemize}[noitemsep]
\item g = f(n) for some n $\in$ \texttype{Int}
\end{itemize}

에서 n의 값에 따라 여러 변환이 가능하다. 따라서 이 두 함수간의 변환은 결정적이지 않고,
안전하지 못하다.

위 두 함수 변환에서부터 안전성이 어떤 성질인지 이해해 볼 수 있다. 첫번째 함수변환의 경우에는 어떤 함수를 변환하였을 때 증명하는 과정에 관계없이 하나의 결과만이 가능함을 알 수 있다. 반면, 두번째 함수변환의 경우에는 함수를 변환하였을 때 증명하는 과정에 따라 여러 결과가 나올 수 있고, 함수변환을 사용하는 사람은 자신이 어떤 결과를 얻을지 예상할 수 없다. 따라서 올바른 함수변환으로 사용하기 위해서는 함수변환이 안전해야만 한다.

또한, 위의 두 함수 변환들을 모두 동어반복명제의 증명으로 사용할 수 있음에 유의하면,
다음과 같은 동어반복명제들이 증명되었음을 알 수 있다.

\begin{itemize}[noitemsep]
\item $S$: $\forall{}P, Q, R . (P \rightarrow{} Q) \rightarrow{} R \rightarrow{} P \rightarrow{} Q$
\item $T$: $\forall{}P, Q . (Int \rightarrow{} P \rightarrow{} Q) \rightarrow{} P \rightarrow{} Q$
\end{itemize}

이 중 $S$ 와 같이 증명이 안전한 함수변환인 명제를 안전한 명제라고 부르고,
$T$와 같이 증명이 안전하지 않은 함수변환인 명제를 안전하지 않은 명제라고 부르면, 어떤 명제의 증명을 올바른 함수변환으로 사용하기 위해서는 그 명제가 안전한 명제여야만 한다는 것을 알 수 있다.

\subsubsection{안전성과 타입 클래스}


\section{결론}

\section{참고문헌}
\begin{enumerate}[label=(\arabic*)]
\item 
\end{enumerate}

\newpage{}
\appendix
\section{부록}
\subsection{구현}
Haskell 소스 코드

\end{document}
% Use C-c C-n
%%% Local Variables:
%%% TeX-engine: xetex
%%% TeX-command-extra-options: "-shell-escape"
%%% End: